# 寄存器

+ 一个典型的CPU由运算器,控制器,寄存器等部件构成
+ 内部总线(区别于外部总线)实现CPU内部各个器件之间的联系
+ 在CPU中
  1. 运算器进行信息处理
  2. 寄存器进行信息存储
  3. 控制器控制各个器件进行工作
  4. 内部总线连接各个器件,在他们之间进行数据的传送
+ 对于汇编程序员来说,寄存器是CPU中可以用指令读写的部件,通过改变各个寄存器中的内容来实现对CPU的控制
+ 8086CPU有14个寄存器,分别是:AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW

## 2.1 通用寄存器

+ 8086CPU中所有的寄存器都是16位的,可以放2Byte
+ ABCD这四个寄存器可以拆分成两个八位寄存器,比如AX可以拆分为AL和AH

## 2.2 字在寄存器中的存储

一个字由两个字节组成,分为高字节和低字节  
在AX寄存器中,AH存放高字节,AL存放低字节

## 2.3 几条汇编指令

1. mov ax,18  
将18送入寄存器AX
2. mov ah,78
将78送入寄存器AH
3. add ax,8
将ax中的数值加上8
4. mov ax,bx
将bx的内容送到ax中
5. add ax,bx
将bx的值加到ax中(ax的值为ax+bx)

## 2.4 物理地址

所有内存单元构成的存储空间是一个一维的线性空间,每个内存单元在这个空间都有一个唯一地址,我们将这个唯一地址称之为物理地址

## 2.5 16位结构的CPU

在8086CPU中,能够一次性处理,传输,暂时储存的信息的最大长度是16位

## 2.6 8086CPU给出物理地址的方法

+ 8086CPU有20位地址总线,可以传输20位地址,达到1MB寻址能力  
同时它又是16位结构,在内部一次性处理,传输,暂时存储的地址为16位,那么每次只能传输16位地址,寻址能力只有64KB
+ 8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址  
当CPU读写内存时,CPU内部提供两个16位地址,一个是段地址,一个是偏移地址  
这两个地址送入地址加法器,合成一个20位的物理地址  
地址加法器合成20位物理地址的方式:  
**物理地址=段地址*16+偏移地址  
也就是段地址左移四位,加上偏移地址

## 2.7 "段地址*16+偏移地址=物理地址"的本质含义

CPU访问内存时,用一个基础地址和一个相对于基础地质的偏移地址相加,给出内存单元的物理地址

## 2.8 "段"的概念

内存没有被分段,这种划分来自于CPU,用"基础地址+偏移地址=物理地址"的方式给出内存单元的物理地址,使得我们可以用分段的方式来管理内存  

这种生成地址的方式有以下特点

1. 段地址*16即**段的起始地址**必然是16的倍数
2. 偏移地址为16位,所以一个段的最大长度为64KB

## 2.9 段寄存器

四个段寄存器,CS,DS,SS,ES  
CS:code segment  
DS:data segment  
SS:stack segment  
ES:Extra segment

## 2.10 CS和IP

+ 在8086CPU中,**任意时刻**,CPU将从内存单元 CS*16+IP 开始,读取一条指令并执行
+ 8086机中,任意时刻,CPU将CS:IP指向的内容当作指令执行
+ 8086CPU工作过程可以简要描述为
  1. 从CS:IP指向的内存单元读取指令,读取的指令进入指令缓冲器
  2. IP=IP+读取的指令的长度,从而使得CS:IP指向下一条指令
  3. 执行指令缓冲器中的指令
  4. 回到1,重复这个过程
+ 8086CPU第一次通电后,CS被设置为FFFFH,IP=0000H,即第一次启动时,将从FFFF0H单元处读取指令并执行,这是CPU开机之后执行的第一条指令

## 2.11 可以修改CS,IP的指令

+ mov指令**无法**操作CS和IP,为什么?intel设计的问他去...
+ jmp用于修改CS:IP  
+ jmp 段地址:偏移地址  
用指定的段地址修改CS,偏移地址修改IP
+ jmp 某一个合法寄存器  
这个指令仅修改IP的值

## 2.12 代码段

由于8086CPU的寻址方式,可以将某个段的一组连续内存用来存放代码,将CS:IP指向代码段的开始位置,当然这只是一种主观上的安排

## 查看CPU,内存,用机器指令和h汇编指令编程

### Debug

Debug是一个调试程序,是运行在DOS和Windows上的程序,它可以查看修改寄存器和内存,在机器码层面追踪程序的运行

#### Debug命令

1. R 查看,修改cpu寄存器的内容
2. D 查看内存中的内容
3. E 修改内存
4. U 将内存中的机器指令翻译成汇编指令
5. T 执行一条机器指令
6. A 用汇编指令的格式写一条机器指令

+ r ax  
修改ax内容,可以写成rax
+ d 地址
展示接下来8行F个内存单元的内容
+ e 地址
一个字节一个字节的写入
+ u 地址
将数据看作代码,并显示汇编指令
+ a 地址 + 汇编
以汇编指令的形式写入机器指令
