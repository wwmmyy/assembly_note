# 更灵活的定位内存地址的方法

## 7.1 and和or指令

1. and指令,逻辑与指令,按位进行与运算  
mov al,01100011B  
and al,00111011B  
结果为(al)=00100011B  
and指令将相应位设0,其他的位不变

2. or指令,逻辑或指令,按位进行或运算  
mov al,01100011B
or  al,00111011B  
结果为(al)=01111011B
or指令将相应位设1,其他位不变

## 7.2 ASCII码

一种编码规范,一个字节的数据表示一个字符,比如61H表示小写字母"a"

## 7.3 以字符形式给出的数据

汇编源程序中,dw "hiahia"会被hiahia的实际ascii码代替

## 7.4 大小写的转换问题

小写字母的ascii码比大写的码值大20H

将第五位置0,则他就是大写字母;置1,为小写字母

## 7.5 [bx+idata]

一种更灵活的地址定位方式

**mov ax,[bx+200]**  
表示:将一个内存单元的内容送入ax,这个内存单元长度为2个字节(一个字单元),存放一个字,偏移地址为bx中的值加上200,段地址放在DS寄存器中  
用符号表示为
(ax)=((ds)*16+(bx)+200)  
这个指令也可以写成:  
mov ax,[200+bx]  
mov ax,200[bx]
mov ax,[bx].200

## 7.6 用[bx+idata]的方式进行数组的处理

## 7.7 SI和DI

si和di是8086CPU中和bx功能相近的寄存器,但是不能拆成八位来使用

mov ax,[bx+20]和mov ax,[di+20]实现的功能是相同的

## 7.8 [bx+si]和[bx+di]

除了使用[bx/si/di+idata]来指明内存之外,还可以使用[bx+si]和[bx+di]

## 7.9 [bx+si+idata]和[bx+di+idata]

注意si和di不能放在一起用,但是mov si,di是可以的,甚至是mov si,bx.si也是合法的

## 不同寻址方式的灵活应用

1. [idata]  用一个常量来表示内存地址,用于直接定位一个内存单元
2. [bx] 用一个变量来表示内存地址,间接定位
3. [bx+idata]   在一个起始地址上,间接定位
4. [bx+si]  用两个变量来定位
5. [bx+si+idata]    用两个变量和一个基础地址间接定位
