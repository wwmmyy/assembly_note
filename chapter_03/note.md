# 寄存器(内存访问)

从访问内存的角度学习寄存器

## 3.1 内存中字的存储

+ 一个寄存器16位,刚好可以储存一个字,高八位存放高字节,低八位存放低字节  
同样在内存中,两个连续的内存单元存放一个字,低地址放低字节,高地址放高字节
+ 字单元概念:存放一个字形数据(16位)的内存单元,由连续内存单元组成,高地址放高位字节,低地址放低位字节

## 3.2 DS和[address]

+ DS是一个**段寄存器**,通常用来存放要访问的数据的段地址
+ 无法用mov直接操作ds赋值,需要使用普通寄存器进行传值
+ 示例:  
mov bx,1000H  
mov ds,bx  
mov al,[0]  
最后一条[]中的0表示偏移地址,定位一个内存单元需要段地址:偏移地址,偏移地址在哪呢?DS里边  
代表将DS:[0]号内存单元中的一个字节送到AL中

## 3.3 字的传送

8086CPU是16位结构,可以一次传送16位数据,也就是一个字

## 3.4 mov,add,sub指令

## 3.5 数据段

将一段内存当作数据段,是一种编程上的安排,可以将段地址放在DS中

## 3.6 栈

栈是一种具有特殊访问方式的存储空间,最后进入的数据,最先出来

## 3.7 CPU提供的栈机制

提供了入栈和出栈的指令,PUSH(入栈)和POP(出栈)  
push ax 表示将ax中的内容入栈  
pop ax 表示将栈顶的数据送入ax  
入栈和出栈是以字为单位的,即一次性操作两个字节(16位)

### 那么"栈"在哪呢?

任意时刻,SS:SP指向栈顶  
push和pop指令都把ss:sp指向的那个字当作栈顶  
同时,不存在栈底的概念,stackoverflow的问题cpu不负责解决

### 完整的描述PUSH指令

push ax 的执行过程:

1. SP = SP-2  
入栈之后,修改栈顶指向  
为什么是减号?因为入栈之后,栈顶地址降低了  
为什么减2?因为入栈出栈每次都是操作一个字的大小,即2个字节
2. 将ax中的内容送到SS:SP处的内存单元

## 3.8 栈顶超界的问题

CPU只知道栈顶,不知道栈有多大,需要编程时合理安排

## 3.9 push和pop指令

push和pop指令可以操作段寄存器,甚至是内存单元  
push [2] 代表将ds:[2]处的一个字入栈  
push和pop操作,只是修改SP,也就是说栈顶的最大变化是0~FFFFH

## 3.10 栈段

将一段内存当作栈,只是一种编程上的安排  
一个栈段最大为64KB  

## 用机器指令和汇编指令编程

略
